-- Emerson Hub V2.6.9 (Studio-safe, SpeedMenu movible y deslizable)
-- USAR SOLO EN ROBLOX STUDIO PARA PRUEBAS (StarterPlayerScripts)
-- NO incluye nada para ejecutores externos.

local RunService = game:GetService("RunService")
if not RunService:IsStudio() then
    warn("[Emerson v2.6.9] Dise√±ado para Roblox Studio (modo prueba). Abortando fuera de Studio.")
    return
end

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer and LocalPlayer:WaitForChild("PlayerGui")

-- Notificaci√≥n (estilo V2.6.3)
local function LocalShow(msg)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = "Emerson Hub",
            Text = msg,
            Duration = 2
        })
    end)
end

-- Estados (persisten en sesi√≥n)
local _States = {
    SpeedBoost = false,
    SpeedChoice = 3,      -- 1..5
    SpeedMultiplier = 2,  -- mapeado desde SpeedChoice
    MultiJump = false,
    Noclip = false
}
local originalWalkSpeed = nil

local function choiceToMultiplier(choice)
    choice = tonumber(choice) or 1
    if choice <= 1 then return 1 end
    if choice == 2 then return 1.5 end
    if choice == 3 then return 2 end
    if choice == 4 then return 2.5 end
    return 3
end

-- ===== UI CREATION (mantener apariencia EXACTA) =====
local function createUI()
    local gui = Instance.new("ScreenGui")
    gui.Name = "EmersonHub_v2_6_9"
    gui.ResetOnSpawn = false
    gui.Parent = PlayerGui

    local frame = Instance.new("Frame", gui)
    frame.Name = "MainFrame"
    frame.Size = UDim2.new(0, 260, 0, 300)
    frame.Position = UDim2.new(0.35, 0, 0.22, 0)
    frame.BackgroundColor3 = Color3.fromRGB(255,255,255)
    local rc = Instance.new("UICorner", frame); rc.CornerRadius = UDim.new(0,8)

    local titleBar = Instance.new("Frame", frame)
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1,0,0,36)
    titleBar.BackgroundTransparency = 1

    local titleLabel = Instance.new("TextLabel", titleBar)
    titleLabel.Size = UDim2.new(0.85,0,1,0)
    titleLabel.Position = UDim2.new(0,6,0,0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = Enum.Font.Gotham
    titleLabel.TextScaled = true
    titleLabel.Text = "ü¶∑ Emerson Hub ‚Äî v2.6.9"
    titleLabel.TextColor3 = Color3.fromRGB(0,0,0)
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left

    local toothBtn = Instance.new("TextButton", titleBar)
    toothBtn.Size = UDim2.new(0.14, -8, 0.9, 0)
    toothBtn.Position = UDim2.new(0.86, 4, 0.05, 0)
    toothBtn.Text = "ü¶∑"
    toothBtn.Font = Enum.Font.SourceSans
    toothBtn.TextScaled = true
    toothBtn.BackgroundTransparency = 1

    local miniBtn = Instance.new("TextButton", gui)
    miniBtn.Name = "MiniBtn"
    miniBtn.Size = UDim2.new(0, 44, 0, 44)
    miniBtn.Position = frame.Position
    miniBtn.Text = "ü¶∑"
    miniBtn.Font = Enum.Font.SourceSans
    miniBtn.TextScaled = true
    miniBtn.BackgroundTransparency = 0.2
    miniBtn.Visible = false
    local miniRC = Instance.new("UICorner", miniBtn); miniRC.CornerRadius = UDim.new(0,8)

    local Scroll = Instance.new("ScrollingFrame", frame)
    Scroll.Name = "OptionsScroll"
    Scroll.Size = UDim2.new(1, -16, 1, -56)
    Scroll.Position = UDim2.new(0,8,0,40)
    Scroll.BackgroundTransparency = 1
    Scroll.ScrollBarThickness = 6
    local layout = Instance.new("UIListLayout", Scroll); layout.Padding = UDim.new(0,8); layout.SortOrder = Enum.SortOrder.LayoutOrder
    local pad = Instance.new("UIPadding", Scroll); pad.PaddingLeft = UDim.new(0,6); pad.PaddingRight = UDim.new(0,6); pad.PaddingTop = UDim.new(0,6)

    -- rainbow driver
    local rainbow = {h = 0, col = Color3.fromRGB(255,0,0)}
    task.spawn(function()
        while gui.Parent do
            rainbow.h = (rainbow.h + 3) % 360
            rainbow.col = Color3.fromHSV(rainbow.h/360, 1, 1)
            task.wait(0.04)
        end
    end)

    local function CreateOption(name, callback)
        local rect = Instance.new("Frame", Scroll)
        rect.Name = "OptRect_"..name:gsub("%s+","")
        rect.Size = UDim2.new(1,0,0,36)
        rect.BackgroundColor3 = Color3.fromRGB(119,136,153)
        local rcc = Instance.new("UICorner", rect); rcc.CornerRadius = UDim.new(0,6)
        local stroke = Instance.new("UIStroke", rect); stroke.Thickness = 2
        local btn = Instance.new("TextButton", rect)
        btn.Size = UDim2.new(1,-8,1,-8); btn.Position = UDim2.new(0,4,0,4)
        btn.BackgroundTransparency = 1
        btn.Font = Enum.Font.SourceSans
        btn.TextScaled = true
        btn.Text = name
        btn.TextColor3 = rainbow.col
        btn.AutoButtonColor = true
        if callback then btn.MouseButton1Click:Connect(function() pcall(callback) end) end
        task.spawn(function()
            while rect.Parent do
                stroke.Color = rainbow.col
                if btn.Parent then btn.TextColor3 = rainbow.col end
                task.wait(0.04)
            end
        end)
        return rect, btn
    end

    -- draggable via titleBar
    local dragging, dragStart, startPos
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    UIS.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    local minimized = false
    local function minimize() minimized = true; frame.Visible = false; miniBtn.Position = frame.Position; miniBtn.Visible = true end
    local function restore() minimized = false; frame.Visible = true; miniBtn.Visible = false end
    toothBtn.MouseButton1Click:Connect(function() if minimized then restore() else minimize() end end)
    miniBtn.MouseButton1Click:Connect(function() restore() end)

    return {
        Gui = gui,
        Frame = frame,
        Scroll = Scroll,
        CreateOption = CreateOption,
        ShowMessage = LocalShow
    }
end

local UI = createUI()

-- ===== character binding & reapply logic (robusto) =====
local savedPos = nil
local teleportConn = nil

local char, humanoid, rootPart

local function applyStatesToHumanoid(hum)
    if not hum then return end
    pcall(function()
        if not originalWalkSpeed or originalWalkSpeed <= 0 then
            originalWalkSpeed = hum.WalkSpeed or 16
        end
    end)
    pcall(function() hum.WalkSpeed = originalWalkSpeed end)
    if _States.SpeedBoost then
        local mult = _States.SpeedMultiplier or choiceToMultiplier(_States.SpeedChoice)
        pcall(function() hum.WalkSpeed = math.max(1, (originalWalkSpeed or 16) * mult) end)
    end
    if _States.Noclip and LocalPlayer.Character then
        for _,p in ipairs(LocalPlayer.Character:GetDescendants()) do
            if p:IsA("BasePart") then pcall(function() p.CanCollide = false end) end
        end
    end
end

local function robustReapply()
    for _,d in ipairs({0.02, 0.09, 0.25}) do
        task.delay(d, function()
            if humanoid then
                applyStatesToHumanoid(humanoid)
            else
                if LocalPlayer.Character then
                    humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                    rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if humanoid then applyStatesToHumanoid(humanoid) end
                end
            end
        end)
    end
end

function bindCharacterEnhanced(c)
    if not c then return end
    char = c
    humanoid = c:FindFirstChildOfClass("Humanoid") or c:WaitForChild("Humanoid")
    rootPart = c:FindFirstChild("HumanoidRootPart") or c:WaitForChild("HumanoidRootPart")

    pcall(function()
        if humanoid and (not originalWalkSpeed or originalWalkSpeed <= 0) then
            originalWalkSpeed = humanoid.WalkSpeed or 16
        end
    end)

    applyStatesToHumanoid(humanoid)

    if teleportConn and teleportConn.Disconnect then
        pcall(function() teleportConn:Disconnect() end)
        teleportConn = nil
    end

    if rootPart then
        local last = rootPart.CFrame
        teleportConn = rootPart:GetPropertyChangedSignal("CFrame"):Connect(function()
            local dist = (rootPart.CFrame.p - last.p).magnitude
            last = rootPart.CFrame
            if dist > 6 then
                robustReapply()
            end
        end)
    end
end

Players.LocalPlayer.CharacterAdded:Connect(function(c) bindCharacterEnhanced(c) end)
if Players.LocalPlayer.Character then bindCharacterEnhanced(Players.LocalPlayer.Character) end

-- ===== Options (mantener orden y nombres) =====
UI.CreateOption("Guardar TP 1", function()
    if rootPart and rootPart.CFrame then
        savedPos = rootPart.CFrame
        UI.ShowMessage("üìç TP 1 guardado")
    else
        UI.ShowMessage("‚ö†Ô∏è No se pudo guardar posici√≥n")
    end
end)

UI.CreateOption("Ir a TP 1", function()
    if savedPos and rootPart then
        pcall(function() rootPart.CFrame = savedPos end)
        robustReapply()
        UI.ShowMessage("‚úÖ Teletransportado a TP 1")
    else
        UI.ShowMessage("‚ö†Ô∏è No hay TP guardado")
    end
end)

UI.CreateOption("Multi Jump", function()
    _States.MultiJump = not _States.MultiJump
    if _States.MultiJump then UI.ShowMessage("üü¢ Multi Jump activado") else UI.ShowMessage("üî¥ Multi Jump desactivado") end
end)

-- ===== Speed Boost menu (ahora MOVIBLE + deslizado suave al abrir) =====
local SpeedMenu = Instance.new("Frame")
SpeedMenu.Name = "SpeedMenu"
SpeedMenu.Size = UDim2.new(0, 160, 0, 120)
SpeedMenu.Position = UI.Frame.Position + UDim2.new(0, UI.Frame.Size.X.Offset + 8, 0, 0)
SpeedMenu.AnchorPoint = Vector2.new(0,0)
SpeedMenu.BackgroundColor3 = Color3.fromRGB(30,30,30)
SpeedMenu.BorderSizePixel = 0
SpeedMenu.Visible = false
SpeedMenu.Parent = UI.Gui
local smRC = Instance.new("UICorner", SpeedMenu); smRC.CornerRadius = UDim.new(0,8)

-- Title (usado tambi√©n como arrastre)
local smTitle = Instance.new("TextLabel", SpeedMenu)
smTitle.Size = UDim2.new(1, -10, 0, 24)
smTitle.Position = UDim2.new(0, 8, 0, 6)
smTitle.BackgroundTransparency = 1
smTitle.Font = Enum.Font.GothamBold
smTitle.TextScaled = true
smTitle.TextColor3 = Color3.new(1,1,1)
smTitle.Text = "Speed Boost"

local inputLabel = Instance.new("TextLabel", SpeedMenu)
inputLabel.Size = UDim2.new(1, -16, 0, 22)
inputLabel.Position = UDim2.new(0, 8, 0, 36)
inputLabel.BackgroundTransparency = 1
inputLabel.Font = Enum.Font.Gotham
inputLabel.TextScaled = true
inputLabel.TextColor3 = Color3.new(1,1,1)
inputLabel.Text = "Valor (1-5):"

local inputBox = Instance.new("TextBox", SpeedMenu)
inputBox.Size = UDim2.new(0, 60, 0, 26)
inputBox.Position = UDim2.new(0, 8, 0, 60)
inputBox.BackgroundColor3 = Color3.fromRGB(245,245,245)
inputBox.ClearTextOnFocus = false
inputBox.Text = tostring(_States.SpeedChoice)
inputBox.Font = Enum.Font.SourceSans
inputBox.TextScaled = true
inputBox.TextColor3 = Color3.fromRGB(0,0,0)
inputBox.PlaceholderText = "1-5"

local applyBtn = Instance.new("TextButton", SpeedMenu)
applyBtn.Size = UDim2.new(0, 72, 0, 26)
applyBtn.Position = UDim2.new(0, 86, 0, 60)
applyBtn.Text = "Set"
applyBtn.Font = Enum.Font.Gotham
applyBtn.TextScaled = true
applyBtn.BackgroundColor3 = Color3.fromRGB(200,200,200)
applyBtn.TextColor3 = Color3.fromRGB(0,0,0)

local onOffBtn = Instance.new("TextButton", SpeedMenu)
onOffBtn.Size = UDim2.new(0, 140, 0, 30)
onOffBtn.Position = UDim2.new(0, 10, 0, 92)
onOffBtn.Text = (_States.SpeedBoost and "ON" or "OFF")
onOffBtn.Font = Enum.Font.GothamBold
onOffBtn.TextScaled = true
onOffBtn.BackgroundColor3 = (_States.SpeedBoost and Color3.fromRGB(90,200,90) or Color3.fromRGB(200,90,90))
onOffBtn.TextColor3 = Color3.new(1,1,1)

local function updateSpeedMenuVisuals()
    inputBox.Text = tostring(_States.SpeedChoice)
    _States.SpeedMultiplier = choiceToMultiplier(_States.SpeedChoice)
    onOffBtn.Text = (_States.SpeedBoost and "ON" or "OFF")
    onOffBtn.BackgroundColor3 = (_States.SpeedBoost and Color3.fromRGB(90,200,90) or Color3.fromRGB(200,90,90))
end
updateSpeedMenuVisuals()

applyBtn.MouseButton1Click:Connect(function()
    local v = tonumber(inputBox.Text)
    if not v then
        UI.ShowMessage("‚ö†Ô∏è Ingresa n√∫mero 1-5")
        return
    end
    v = math.clamp(math.floor(v), 1, 5)
    _States.SpeedChoice = v
    _States.SpeedMultiplier = choiceToMultiplier(v)
    UI.ShowMessage("üîß Speed set a "..tostring(v).." (x"..tostring(_States.SpeedMultiplier)..")")
    if _States.SpeedBoost and humanoid then
        applyStatesToHumanoid(humanoid)
    end
    updateSpeedMenuVisuals()
end)

onOffBtn.MouseButton1Click:Connect(function()
    _States.SpeedBoost = not _States.SpeedBoost
    _States.SpeedMultiplier = _States.SpeedMultiplier or choiceToMultiplier(_States.SpeedChoice)
    if _States.SpeedBoost then
        UI.ShowMessage("üü¢ Speed Boost ON (x"..tostring(_States.SpeedMultiplier)..")")
    else
        UI.ShowMessage("üî¥ Speed Boost OFF")
    end
    if humanoid then applyStatesToHumanoid(humanoid) end
    updateSpeedMenuVisuals()
end)

-- ===== MOVER SpeedMenu: arrastrar + suavizado al abrir =====
local speedDragging = false
local speedDragStart = Vector2.new(0,0)
local speedStartAbsPos = Vector2.new(0,0)
local speedHasBeenMoved = false

smTitle.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        speedDragging = true
        speedDragStart = input.Position
        -- si AbsolutePosition no existe a√∫n, marcar (se colocar√° al abrir)
        speedStartAbsPos = SpeedMenu.AbsolutePosition
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                speedDragging = false
                speedHasBeenMoved = true
                -- suavizar "snap" final (peque√±o tween para suavidad)
                local tgtPos = SpeedMenu.Position
                local tweenInfo = TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                pcall(function() TweenService:Create(SpeedMenu, tweenInfo, {Position = tgtPos}):Play() end)
            end
        end)
    end
end)

UIS.InputChanged:Connect(function(input)
    if speedDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - speedDragStart
        local newX = speedStartAbsPos.X + delta.X
        local newY = speedStartAbsPos.Y + delta.Y
        SpeedMenu.Position = UDim2.new(0, math.floor(newX), 0, math.floor(newY))
    end
end)

local function positionSpeedMenuIfNeeded()
    if not speedHasBeenMoved then
        pcall(function()
            local f = UI.Frame
            if f then
                local pos = f.AbsolutePosition
                local size = f.AbsoluteSize
                local target = UDim2.new(0, pos.X + size.X + 8, 0, pos.Y)
                -- Tween to position for smooth slide
                local tweenInfo = TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                pcall(function() TweenService:Create(SpeedMenu, tweenInfo, {Position = target}):Play() end)
            end
        end)
    end
end

local speedMenuVisible = false
local function toggleSpeedMenu()
    speedMenuVisible = not speedMenuVisible
    SpeedMenu.Visible = speedMenuVisible
    if speedMenuVisible then
        positionSpeedMenuIfNeeded()
    end
end

UI.CreateOption("Speed Boost", function() toggleSpeedMenu() end)

-- ===== Noclip (sin cambios) =====
UI.CreateOption("Noclip", function()
    _States.Noclip = not _States.Noclip
    if _States.Noclip then
        if LocalPlayer.Character then
            for _,part in ipairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then pcall(function() part.CanCollide = false end) end
            end
        end
        UI.ShowMessage("üü¢ Noclip activado")
    else
        UI.ShowMessage("üî¥ Noclip desactivado")
    end
end)

-- ===== Multi Jump handling (igual comportamiento) =====
local holdingJump = false
local lastHoldPulse = 0
local holdImpulse = 4.5
local holdInterval = 0.12
local maxHoldY = 55

UIS.JumpRequest:Connect(function()
    if not _States.MultiJump or not humanoid or not rootPart then return end
    pcall(function()
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        humanoid.Jump = true
    end)
    holdingJump = true
    lastHoldPulse = tick()
    task.delay(0.55, function()
        if tick() - lastHoldPulse > 0.52 then holdingJump = false end
    end)
end)

UIS.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.Space then
            holdingJump = true
            lastHoldPulse = tick()
        elseif input.KeyCode == Enum.KeyCode.LeftControl then
            UI.Frame.Visible = not UI.Frame.Visible
            if UI.Frame.Visible then UI.ShowMessage("üîì Panel mostrado") else UI.ShowMessage("üîí Panel minimizado") end
        end
    end
end)
UIS.InputEnded:Connect(function(input, gpe)
    if gpe then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
        holdingJump = false
    end
end)

RunService.Heartbeat:Connect(function(dt)
    if _States.MultiJump and holdingJump and humanoid and rootPart then
        local now = tick()
        if now - lastHoldPulse >= holdInterval then
            lastHoldPulse = now
            pcall(function()
                local v = rootPart.Velocity
                local newY = math.min(v.Y + holdImpulse, maxHoldY)
                rootPart.Velocity = Vector3.new(v.X, newY, v.Z)
            end)
        end
    end

    if _States.Noclip and LocalPlayer.Character then
        for _,pn in pairs({"HumanoidRootPart","Torso","UpperTorso","LowerTorso","Head"}) do
            local p = LocalPlayer.Character:FindFirstChild(pn)
            if p and p:IsA("BasePart") then p.CanCollide = false end
        end
    end
end)

-- Rebind on respawn & initial
Players.LocalPlayer.CharacterAdded:Connect(function(c)
    bindCharacterEnhanced(c)
    robustReapply()
end)

_States.SpeedMultiplier = choiceToMultiplier(_States.SpeedChoice)
UI.ShowMessage("‚úÖ Emerson Hub v2.6.9 cargado (Speed menu movible, deslizado suave).")
